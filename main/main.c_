#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/param.h>
#define TAG "EliteProject MOIN"
#include "esp_err.h"
#include "esp_wifi.h"
#include "esp_system.h"
#include "esp_event.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "esp_netif.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "led_strip.h"

#include "esp_ota_ops.h"
#include "esp_http_client.h"
#include "esp_https_ota.h"
#include "lwip/err.h"
#include "lwip/sockets.h"
#include "lwip/sys.h"
#include <lwip/netdb.h>
#include "lwip/opt.h"

#include "monster.h"
#include "mr_display.h"
#include "elite.h"

#define HASH_LEN 32


#define EXAMPLE_ESP_WIFI_SSID      "wlan0"
#define EXAMPLE_ESP_WIFI_PASS      "messwiththebestdieliketherest"
#define EXAMPLE_ESP_MAXIMUM_RETRY  5

#ifndef SOCK_TARGET_HOST
#define SOCK_TARGET_HOST  "192.168.0.249"
#endif

#ifndef SOCK_TARGET_PORT
#define SOCK_TARGET_PORT  9001
#endif


#if CONFIG_ESP_WPA3_SAE_PWE_HUNT_AND_PECK
#define ESP_WIFI_SAE_MODE WPA3_SAE_PWE_HUNT_AND_PECK
#define EXAMPLE_H2E_IDENTIFIER ""
#elif CONFIG_ESP_WPA3_SAE_PWE_HASH_TO_ELEMENT
#define ESP_WIFI_SAE_MODE WPA3_SAE_PWE_HASH_TO_ELEMENT
#define EXAMPLE_H2E_IDENTIFIER CONFIG_ESP_WIFI_PW_ID
#elif CONFIG_ESP_WPA3_SAE_PWE_BOTH
#define ESP_WIFI_SAE_MODE WPA3_SAE_PWE_BOTH
#define EXAMPLE_H2E_IDENTIFIER CONFIG_ESP_WIFI_PW_ID
#endif
#if CONFIG_ESP_WIFI_AUTH_OPEN
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_OPEN
#elif CONFIG_ESP_WIFI_AUTH_WEP
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WEP
#elif CONFIG_ESP_WIFI_AUTH_WPA_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA_PSK
#elif CONFIG_ESP_WIFI_AUTH_WPA2_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA2_PSK
#elif CONFIG_ESP_WIFI_AUTH_WPA_WPA2_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA_WPA2_PSK
#elif CONFIG_ESP_WIFI_AUTH_WPA3_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA3_PSK
#elif CONFIG_ESP_WIFI_AUTH_WPA2_WPA3_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WPA2_WPA3_PSK
#elif CONFIG_ESP_WIFI_AUTH_WAPI_PSK
#define ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD WIFI_AUTH_WAPI_PSK
#endif

#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1

#define PORT CONFIG_EXAMPLE_PORT
#ifdef CONFIG_EXAMPLE_SOCKET_IP_INPUT_STDIN
#include "addr_from_stdin.h"
#endif

#if defined(CONFIG_EXAMPLE_IPV4)
#define HOST_IP_ADDR CONFIG_EXAMPLE_IPV4_ADDR
#elif defined(CONFIG_EXAMPLE_IPV6)
#define HOST_IP_ADDR CONFIG_EXAMPLE_IPV6_ADDR
#else
#define HOST_IP_ADDR ""
#endif





//static const char *TAG = "EliteProject Main";
static int s_retry_num = 0;
static size_t globalLogBuffer_size=512;
static char* globalLogBuffer=NULL;
static int n_main_loops_limit=100000;
//static int counter=0;
static EventGroupHandle_t s_wifi_event_group;

static bool exit_condition=false;


static void elite_wifi_event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data){
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        if (s_retry_num < EXAMPLE_ESP_MAXIMUM_RETRY) {
            esp_wifi_connect();
            s_retry_num++;
            ESP_LOGI(TAG, "retry to connect to the AP");
        } else {
            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);
        }
        ESP_LOGI(TAG,"connect to the AP fail");
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "got ip:" IPSTR, IP2STR(&event->ip_info.ip));
        s_retry_num = 0;
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}


static void elite_init_nvs(){
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);

};

static void elite_init_wifi(){
    ESP_LOGI(TAG, "ESP_WIFI_MODE_STA");

        s_wifi_event_group = xEventGroupCreate();

        ESP_ERROR_CHECK(esp_netif_init());
        ESP_ERROR_CHECK(esp_event_loop_create_default());
        esp_netif_create_default_wifi_sta();

        wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
        ESP_ERROR_CHECK(esp_wifi_init(&cfg));

        esp_event_handler_instance_t instance_any_id;
        esp_event_handler_instance_t instance_got_ip;

        ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
                                                            ESP_EVENT_ANY_ID,
                                                            &elite_wifi_event_handler,
                                                            NULL,
                                                            &instance_any_id));
        ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,
                                                            IP_EVENT_STA_GOT_IP,
                                                            &elite_wifi_event_handler,
                                                            NULL,
                                                            &instance_got_ip));

        wifi_config_t wifi_config = {
            .sta = {
                .ssid = EXAMPLE_ESP_WIFI_SSID,
                .password = EXAMPLE_ESP_WIFI_PASS,
                .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,
                .sae_pwe_h2e = ESP_WIFI_SAE_MODE,
                .sae_h2e_identifier = EXAMPLE_H2E_IDENTIFIER,
            },
        };
        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) );
        ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config) );
        ESP_ERROR_CHECK(esp_wifi_start() );

        ESP_LOGI(TAG, "wifi_init_sta finished.");

            EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,
                  WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,
                  pdFALSE,
                  pdFALSE,
                  portMAX_DELAY);

            if (bits & WIFI_CONNECTED_BIT) {
                ESP_LOGI(TAG, "connected to ap SSID:%s password:%s",
                        EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
            } else if (bits & WIFI_FAIL_BIT) {
                ESP_LOGI(TAG, "Failed to connect to SSID:%s, password:%s",
                     EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS);
                   } else {
                     ESP_LOGE(TAG, "UNEXPECTED EVENT");
                   }

};


typedef struct {
  int log_socket;
  int intervall;
  char* message;
} elite_logger_task_params_t;

#define TEST_LOG_CMD 1

static void elite_logger_task(void* args){

  elite_logger_task_params_t p_my_params;
  p_my_params.message="moin";

  ESP_LOGI(TAG, "Initializing Logger Socket");
  int s;
  int ret;
  struct sockaddr_in addr;
  memset(&addr, 0, sizeof(addr));
  addr.sin_len = sizeof(addr);
  addr.sin_family = AF_INET;
  addr.sin_port = PP_HTONS(SOCK_TARGET_PORT);
  addr.sin_addr.s_addr = inet_addr(SOCK_TARGET_HOST);

  s = lwip_socket(AF_INET, SOCK_DGRAM, 0);

  if (s>=0) {
    ESP_LOGI(TAG, "Socket %d, udp , target_addr %s, port %d",s,SOCK_TARGET_HOST,SOCK_TARGET_PORT);
  }else ESP_LOGE(TAG, "Socket initalizing failed");

//  ESP_LOGI(TAG, "Testing connect()");

  ret = lwip_connect(s, (struct sockaddr*)&addr, sizeof(addr));
  if (ret!=0) {ESP_LOGE(TAG, "Connect didnt work: errno %d ret %d", errno,ret);}
  else ESP_LOGD(TAG, "Connect worked: errno %d ret %d", errno,ret);
  LWIP_ASSERT("connect ret == 0", ret==0);

  ESP_LOGI(TAG, "Testing write()");
  const char* m="hello again!\n";
  ret = lwip_write(s, m, sizeof(m));
  //if (ret<14) {ESP_LOGE(TAG, "write didnt work: errno %d ret %d", errno,ret);}
  //else ESP_LOGD(TAG, "write() worked: errno %d ret %d", errno,ret);
  //LWIP_ASSERT("write ret == 13", ret >= 14);
//  FILE *fp = fdopen(s, "w+");
//  fprintf(fp,"lalala socket: %d",s);

  //ESP_LOGI(TAG, "Testing close()");

/*  ret = lwip_close(s);
  if (ret!=0) {ESP_LOGE(TAG, "close() didnt work: errno %d ret %d", errno,ret);}
  else ESP_LOGI(TAG, "close() worked: errno %d ret %d", errno,ret);
  LWIP_ASSERT("close ret == 0", ret == 0);
*/


globalLogBuffer=(char*)malloc(globalLogBuffer_size*sizeof(char));

   uint32_t ulNotificationValue;
   int num=0;
  while (true) {
    //ESP_LOGI("elitelogger", "messageStr=%s",p_my_params.message);
      if (xTaskNotifyWait(0, 0, &ulNotificationValue, portMAX_DELAY)) {
        switch (ulNotificationValue) {

          case TEST_LOG_CMD : {
              //ESP_LOGI(TAG, "tx_buf : <%s>",tx_buf);
              size_t max_tx_buf=64;
              char* tx_buf=(char*)malloc(max_tx_buf);
              memset(tx_buf,0,max_tx_buf);
              sprintf(tx_buf,"log4joy : %s %d\n",p_my_params.message,num);
              num++;



              size_t tx_len=strlen(tx_buf);
              ret=lwip_write(s,tx_buf,tx_len);

              if (ret!=tx_len) {ESP_LOGE(TAG, "failed to send something via the udp log socket : %s", tx_buf);}
              else {ESP_LOGI(TAG, "send something via the udp log socket : %s",tx_buf);};

              free(tx_buf);

              ulNotificationValue=0;
              break;
              };
        default :{


            size_t max_tx_buf=512;
            char* tx_buf=(char*)malloc(max_tx_buf);
            memset(tx_buf,0,max_tx_buf);

            sprintf(tx_buf,"log4joy : %s",globalLogBuffer);

            //this is silly because we pass the message length in ulNotificationValue. why use strlen again?!
            size_t tx_len=strlen(tx_buf);

            ret=lwip_write(s,tx_buf,tx_len);
            LWIP_ASSERT("ret==lwip_write(s,tx_buf,tx_len);", ret==tx_len);

            free(tx_buf);
            //ret=lwip_write(s,globalLogBuffer,ulNotificationValue);
            ulNotificationValue=0;
            //vTaskDelay(100 / portTICK_PERIOD_MS);
          };
      };//switch
    };
  //  vTaskDelay(100 / portTICK_PERIOD_MS);
};


  (void)p_my_params;
  (void)args;
};

TaskHandle_t p_elite_logger_task_handle;


void elog(const char* s){

//        size_t *ps=(char)malloc(strlen(s);
configASSERT(globalLogBuffer);
size_t i;
memset(globalLogBuffer,0,globalLogBuffer_size);
for (i=0;((i<strlen(s))&&(i<globalLogBuffer_size-1));i++) {globalLogBuffer[i]=s[i];};
globalLogBuffer[i]=0;//not sure if thats needed but it wont hurt. it could hurt otherwise though
xTaskNotify(p_elite_logger_task_handle,i,3);//3==eSetValueWithOverwrite

};

const int minimum_delay=2500;
const int maximum_add_delay=2500;


static int monsters_get_new_eye_direction(int old_direction){
    //to prevent single eye movement because it just looks stupid;
    int new_dir=esp_random()%6;
    int old_dir=old_direction;
    elog("getting new eye_dir\n");

//    elog("eye_blink\n");

    if (old_dir==DOWN_LEFT) {
      for (;;) {
        if ((new_dir==DOWN_RIGHT)||(new_dir==UP_LEFT)||(new_dir==UP_CENTER)||(new_dir==UP_RIGHT)) {break;}
        else {new_dir+=1;new_dir%=6;};
      };
    };

    if (old_dir==DOWN_CENTER) {
      for (;;) {
        if ((new_dir==UP_LEFT)||(new_dir==UP_CENTER)||(new_dir==UP_RIGHT)){break;}
        else {new_dir+=1;new_dir%=6;};
      };
    };

    if (old_dir==DOWN_RIGHT) {
      for (;;) {
        if ((new_dir==UP_LEFT)||(new_dir==UP_CENTER)||(new_dir==UP_RIGHT)||(new_dir==DOWN_LEFT)){break;}
        else{new_dir+=1;new_dir%=6;};
      };
    };

    if (old_dir==UP_LEFT) {
      for (;;) {
        if ((new_dir==UP_RIGHT)||(new_dir==DOWN_LEFT)||(new_dir==DOWN_CENTER)||(new_dir==DOWN_RIGHT)){break;}
        else{new_dir+=1;new_dir%=6;};
      };
    };

    if (old_dir==UP_CENTER) {
      for (;;) {
        if ((new_dir==DOWN_LEFT)||(new_dir==DOWN_CENTER)||(new_dir==DOWN_RIGHT)){break;}
        else{new_dir+=1;new_dir%=6;};
      };
    };

    if (old_dir==UP_RIGHT) {
      for (;;) {
        if ((new_dir==UP_LEFT)||(new_dir==DOWN_CENTER)||(new_dir==DOWN_RIGHT)||(new_dir==DOWN_LEFT)){break;}
        else {new_dir+=1;new_dir%=6;};
      };
    };
    elog("returning new eye_dir\n");
      return new_dir;

  };

static void eye_task1(void* args){
    int random_delay=minimum_delay+esp_random()%maximum_add_delay;
      while (true) {
        vTaskDelay(random_delay / portTICK_PERIOD_MS);
        elog("blink\n");
        monsters[0].eyes_direction=monsters_get_new_eye_direction(monsters[0].eyes_direction);

        random_delay=minimum_delay+esp_random()%maximum_add_delay;
      };
};

static void eye_task2(void* args){
    int random_delay=minimum_delay+esp_random()%maximum_add_delay;
      while (true) {
        vTaskDelay(random_delay / portTICK_PERIOD_MS);
        elog("blink\n");
        monsters[1].eyes_direction=monsters_get_new_eye_direction(monsters[1].eyes_direction);
        random_delay=minimum_delay+esp_random()%maximum_add_delay;
      };
};

static void eye_task3(void* args){
    int random_delay=minimum_delay+esp_random()%maximum_add_delay;
      while (true) {
        vTaskDelay(random_delay / portTICK_PERIOD_MS);
        elog("blink\n");
        monsters[2].eyes_direction=monsters_get_new_eye_direction(monsters[2].eyes_direction);
        random_delay=minimum_delay+esp_random()%maximum_add_delay;
      };
};


#define OTA_URL_SIZE 256

bool eliteAssert(bool ok,const char* msg){
  if (!ok) {elog(msg);};
  return !ok;
};

void draw_background(){
  for (int yy=0;yy<30;yy++){
    for (int xx=0;xx<10;xx++){
        put_pixel(xx,yy,dark_green);
    };
  };

};

void draw_monsters(){
  for (int i=0;i<NUM_MONSTERS;i++) {
    int offset_y=i*10;
    for (int y=0;y<10;y++){
      for (int x=0;x<10;x++){
        int ci=monster_bitmap[x+y*10];
        if (ci!=0) {
          sRGB c={monsters[i].cols[ci].r,monsters[i].cols[ci].g,monsters[i].cols[ci].b};
          put_pixel(x,y+offset_y,c);
        };
      };
    };
    if (monsters[i].eyes_direction==UP_LEFT) {
        put_pixel(3,offset_y+3,black);
        put_pixel(6,offset_y+3,black);
    };
    if (monsters[i].eyes_direction==UP_CENTER) {
        put_pixel(4,offset_y+3,black);
        put_pixel(6,offset_y+3,black);
    };
    if (monsters[i].eyes_direction==UP_RIGHT) {
        put_pixel(4,offset_y+3,black);
        put_pixel(7,offset_y+3,black);
    };
    if (monsters[i].eyes_direction==DOWN_LEFT) {
        put_pixel(3,offset_y+4,black);
        put_pixel(6,offset_y+4,black);
    };
    if (monsters[i].eyes_direction==DOWN_CENTER) {
        put_pixel(4,offset_y+4,black);
        put_pixel(6,offset_y+4,black);
    };
    if (monsters[i].eyes_direction==DOWN_RIGHT) {
        put_pixel(4,offset_y+4,black);
        put_pixel(7,offset_y+4,black);
    };

  };
};

esp_err_t _http_event_handler(esp_http_client_event_t *evt)
{
    switch (evt->event_id) {
    case HTTP_EVENT_ERROR:
        ESP_LOGD(TAG, "HTTP_EVENT_ERROR");
        break;
    case HTTP_EVENT_ON_CONNECTED:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_CONNECTED");
        break;
    case HTTP_EVENT_HEADER_SENT:
        ESP_LOGD(TAG, "HTTP_EVENT_HEADER_SENT");
        break;
    case HTTP_EVENT_ON_HEADER:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_HEADER, key=%s, value=%s", evt->header_key, evt->header_value);
        break;
    case HTTP_EVENT_ON_DATA:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_DATA, len=%d", evt->data_len);
        break;
    case HTTP_EVENT_ON_FINISH:
        ESP_LOGD(TAG, "HTTP_EVENT_ON_FINISH");
        break;
    case HTTP_EVENT_DISCONNECTED:
        ESP_LOGD(TAG, "HTTP_EVENT_DISCONNECTED");
        break;
    case HTTP_EVENT_REDIRECT:
        ESP_LOGD(TAG, "HTTP_EVENT_REDIRECT");
        break;
    }
    return ESP_OK;
}
static int ota_timer=15000;

void simple_ota_task(void *pvParameter)
{
    ESP_LOGI(TAG, "Starting OTA task");
//#ifdef CONFIG_FIRMWARE_UPGRADE_BIND_IF
    //esp_netif_t *netif = get_netif_from_desc(bind_interface_name);
    //if (netif == NULL) {
        //ESP_LOGE(TAG, "Can't find netif from interface description");
        //abort();
    //}
    //struct ifreq ifr;
    //esp_netif_get_netif_impl_name(netif, ifr.ifr_name);
    //ESP_LOGI(TAG, "Bind interface name is %s", ifr.ifr_name);
//#endif
    esp_http_client_config_t config = {
        .url = "http://192.168.0.249/eliteProject_1_0_1.bin",
        .event_handler = _http_event_handler,
        .keep_alive_enable = true
//#ifdef CONFIG_EXAMPLE_FIRMWARE_UPGRADE_BIND_IF
//        .if_name = &ifr,
//#endif
    };
    esp_https_ota_config_t ota_config = {
        .http_config = &config,
    };
    ESP_LOGI(TAG, "Attempting to download update from %s", config.url);
    esp_err_t ret = esp_https_ota(&ota_config);
    if (ret == ESP_OK) {
        ESP_LOGI(TAG, "OTA Succeed, Rebooting...");
        elog("OTA Succeed, Rebooting...\n");
        vTaskDelay(5000 / portTICK_PERIOD_MS);
        esp_restart();
    } else {
        ESP_LOGE(TAG, "Firmware upgrade failed");
        elog("Firmware upgrade failed\n");
    }
while(ota_timer>0){
    ota_timer-=1000;
    vTaskDelay(1000 / portTICK_PERIOD_MS);
  };
  elog("stopping ota task\n");
    vTaskDelay(1000 / portTICK_PERIOD_MS);
vTaskDelete(NULL);

};
/*
static void print_sha256(const uint8_t *image_hash, const char *label)
    {
        char hash_print[HASH_LEN * 2 + 1];
        hash_print[HASH_LEN * 2] = 0;
        for (int i = 0; i < HASH_LEN; ++i) {
            sprintf(&hash_print[i * 2], "%02x", image_hash[i]);
        }
        ESP_LOGI(TAG, "%s %s", label, hash_print);
    }

static void get_sha256_of_partitions(void)
{
    uint8_t sha_256[HASH_LEN] = { 0 };
    esp_partition_t partition;

    // get sha256 digest for bootloader
    partition.address   = ESP_BOOTLOADER_OFFSET;
    partition.size      = ESP_PARTITION_TABLE_OFFSET;
    partition.type      = ESP_PARTITION_TYPE_APP;
    esp_partition_get_sha256(&partition, sha_256);
    print_sha256(sha_256, "SHA-256 for bootloader: ");

    // get sha256 digest for running partition
    esp_partition_get_sha256(esp_ota_get_running_partition(), sha_256);
    print_sha256(sha_256, "SHA-256 for current firmware: ");
}

*/
void start_ota_task(){
  elog("starting ota task\n");
  xTaskCreate(&simple_ota_task, "ota_task", 8192, NULL, 5, NULL);
  vTaskDelay(1000 / portTICK_PERIOD_MS);
};


void start_eyes_tasks(){
  xTaskCreate(&eye_task1, "eye_task1", 4096, NULL, 5, NULL);
  xTaskCreate(&eye_task2, "eye_task2", 4096, NULL, 5, NULL);
  xTaskCreate(&eye_task3, "eye_task3", 4096, NULL, 5, NULL);
};

void app_main(void){

    elite_init_nvs();
    elite_init_wifi();

    ESP_LOGI(TAG, "Waiting 3 seconds for reasons");
    vTaskDelay(3000 / portTICK_PERIOD_MS);

    led_strip = configure_led_spi();

    int sock = socket(AF_INET, SOCK_DGRAM, 0);

    elite_logger_task_params_t elite_logger_task_params={
      .log_socket=sock,
      .intervall=5000 / portTICK_PERIOD_MS,
      .message="moin"
    };




    xTaskCreate(elite_logger_task, "elite_logger_task", 4096, &elite_logger_task_params, 5, &p_elite_logger_task_handle);
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    elog("hello again\n");
    start_ota_task();
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    start_eyes_tasks();
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    exit_condition=false;

    while (exit_condition!=true) {
          //always quit as default ... in case of stupid
          exit_condition=true;
          //

          if (n_main_loops_limit>0) {
              n_main_loops_limit-=1;
              exit_condition=false;
              ESP_LOGI(TAG, "loop : n_main_loops left %d",n_main_loops_limit);
          };


          if (n_main_loops_limit==0) {
              ESP_LOGI(TAG, "leaving main loop : n_main_loops==0 %d",n_main_loops_limit);
              exit_condition=true;
          };


          if (n_main_loops_limit<0) {
              ESP_LOGE(TAG, "oops : n_main_loops<0 %d",n_main_loops_limit);
              exit_condition=true;
          };

          vTaskDelay(50 / portTICK_PERIOD_MS);


              //xTaskNotify(p_elite_logger_task_handle,TEST_LOG_CMD,3);//3==eSetValueWithOverwrite
              draw_background();
              draw_monsters();
              vTaskDelay(50 / portTICK_PERIOD_MS);
              update_leds();
              vTaskDelay(50 / portTICK_PERIOD_MS);



      };

      ESP_LOGI(TAG, "exit_condition==true;");elog("hier koennte ihre werbung stehen\n");



      ESP_LOGI(TAG, "rebooting in 10");
      elog("rebooting in 10");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 9");
      ESP_LOGI(TAG, "9");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 8");
      ESP_LOGI(TAG, "8");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 7");
      ESP_LOGI(TAG, "7");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 6");
      ESP_LOGI(TAG, "6");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 5");
      ESP_LOGI(TAG, "5");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 4");
      ESP_LOGI(TAG, "4");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 3");
      ESP_LOGI(TAG, "3");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 2");
      ESP_LOGI(TAG, "2");
      vTaskDelay(1000 / portTICK_PERIOD_MS);
      elog("rebooting in 1");
      ESP_LOGI(TAG, "1");
      vTaskDelay(500 / portTICK_PERIOD_MS);
      if (sock != -1) {
          elog("Shutting down socket");
              vTaskDelay(500 / portTICK_PERIOD_MS);
          ESP_LOGE(TAG, "Shutting down socket");
          shutdown(sock, 0);
          close(sock);

      }
      ESP_LOGI(TAG, "rebooting in 0");

      vTaskDelay(500 / portTICK_PERIOD_MS);

      //just for good measure
      free(globalLogBuffer);
      esp_restart();
}
